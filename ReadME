实时推荐系统：
      分为离线和在线两个部分。
            1.离线部分offLine：
                  在不考虑冷启动的情况下，不考虑新加用户，新加产品的情况。
                       每天定时计算usercf 的用户打分矩阵，以及用户相似矩阵 并保存。路径为  ./modelRelation/trainset_ucf.file    ./modelRelaton/user_sim_mat_ucf.file
                       每天定时计算itemcf 的用户打分矩阵，以及产品相似矩阵，并保存。路径为 ./modelRelation/trainset_item.file   ./modelRelation/product_sim_mat.file
                       每天定时计算item2vec 的模型，并保存,路径为                       ./modelRelation/item2vec


                       注：为了对实时部分有较明显的影响，最好两次运行时间不要隔太久
                           根据实际产品量和用户量，考虑是否要跑离线部分，如果不影响实时反馈效果，可以考虑将模型直接放大实时模块运行，即不需要实时。
                           也可以，部分离线部分实时。用户量远大于产品量的话，考虑将usercf放入实时计算，但是usercf本身实时反馈效果一般，产生行为后，不一定立刻有变化。
                           产品量少的话，可以考虑将itemcf放入实时计算，itemcf对行为比较敏感，会导致立刻的推荐变化。

                           不建议将item2vec放入实时计算，比较耗时，可以考虑隔半小时跑一次，一切以实际条件为准吧。
            2.实时部分comsunerMain：
                 思路： 利用canal监听'用户行为的mysql数据表'，将变化数据写进kafka,并实时消费。
                       利用canal监听'用户表'，判断是否加入的新用户，并开启用户冷启动部分。
                       利用canal监听'产品表'，判断是否有产品上架或者下架，若上架，则开启产品冷启动部分。若下架，则在推荐结果中剔除该产品

                 在不考虑冷启动的情况下，不考虑新加用户，新加产品的情况。
                        加载离线部分保存的数据模型文件，实例化模型，监听'用户行为表',为用户提供实时推荐。
                        根据时间，可以考虑放一个算法进实时计算，建议itemcf
                 利用canal监听'用户行为的mysql数据表'  对比用户表和产品表，判断新用户或新产品是否有行为
                         新加入产品后，发现有起调usercf
                         在加入新用户后， 起调itemcf

            3.推荐结果实时处理
                过滤掉下架产品，并且起调数据处理模块，不加载该产品以及该产品（或定期剔除下架产品的行为信息，以防止随着时间积累产品矩阵过大）
                把高曝光低点击的产品往后移 exposure （需要去数据库查表计算，为了节约时间，建议离线计算，保存结果，这里直接取结果）
                混入少量低曝光的产品，用来挖掘长尾分布 （同上）


